## 1. 프로세스란 무엇인가요?

프로세스는 실행 중인 프로그램의 인스턴스로, 메모리에 적재되어 CPU를 할당받아 동작하는 작업의 기본 단위입니다. 즉, 코드, 데이터, 스택, 힙 등의 자원을 포함하는 동적인 실행 개체입니다.

---

## 2. 프로세스와 메모리 섹션의 관계

프로세스의 메모리 구조는 다음 4가지 주요 섹션으로 구성됩니다:

1. 코드(Text) 섹션: 실행 가능한 명령어 저장
2. 데이터(Data) 섹션: 전역변수, 정적변수 저장
3. 스택(Stack) 섹션: 지역변수, 함수 호출 정보 관리
4. 힙(Heap) 섹션: 동적 메모리 할당

각 섹션은 프로세스의 메모리 관리와 실행에 핵심적인 역할을 수행합니다.

---

## 3. 프로세스 상태와 생명주기

프로세스 생명주기는 다음 상태들을 거칩니다:

1. 생성(New): 프로세스 최초 생성 상태
2. 준비(Ready): CPU 할당 대기 상태
3. 실행(Running): CPU 점유 중인 상태
4. 대기(Waiting): I/O 작업 등 이벤트 대기 상태
5. 종료(Terminated): 프로세스 실행 완료 상태

이러한 상태 전이를 통해 프로세스는 시스템 자원을 효율적으로 활용합니다.

1. 프로세스는 생성(New) 상태에서 시작합니다. 프로그램이 메모리에 적재되고 시스템 자원을 할당받습니다.
2. 생성된 프로세스는 곧바로 준비(Ready) 상태로 전환됩니다. CPU 할당을 기다리며 실행할 준비를 완료한 상태입니다.
3. 스케줄러가 프로세스를 선택하면 실행(Running) 상태로 전환됩니다. CPU를 점유하고 실제 명령어를 수행합니다.
4. 실행 중 I/O 작업이나 외부 이벤트가 필요하면 대기(Waiting) 상태로 전환됩니다. 특정 자원이나 이벤트를 기다리는 상태입니다.
5. I/O 작업이 완료되면 다시 준비(Ready) 상태로 돌아갑니다.  CPU 할당을 기다립니다.
6. 최종적으로 모든 작업을 완료하면 종료(Terminated) 상태에 도달합니다. 프로세스는 사용한 자원을 반환하고 시스템에서 제거됩니다.

---

## 4. 프로세스와 스레드의 차이점

프로세스는 독립된 메모리 공간을 가진 실행 단위이고, 스레드는 프로세스 내부의 실행 흐름입니다.

- 프로세스:
• 독립된 메모리 공간
• 자원 할당의 최소 단위
• 높은 격리성
- 스레드:
• 프로세스 내 메모리 공유
• 경량화된 실행 단위
• 자원 공유에 용이

---

## 5. 멀티프로세스 vs 멀티스레드

**멀티프로세스**

**개념**

- 독립된 메모리 공간을 가진 여러 프로세스 동시 실행
- 각 프로세스는 고유의 자원과 메모리 영역 보유

**장점** 

1. 안정성
    - 독립된 메모리 공간으로 인한 높은 격리성
    - 한 프로세스 오류가 다른 프로세스에 영향 미치지 않음
    - 프로세스 충돌 시 다른 프로세스 정상 동작 보장
2. 개별 프로세스 격리
    - 메모리 공간 완전 분리
    - 보안성 향상
    - 시스템 리소스 독립적 관리

**단점** 

1. 메모리 오버헤드
    - 각 프로세스마다 독립 메모리 공간 할당
    - 중복된 코드, 데이터 영역 생성
    - 메모리 사용량 급격히 증가
2. 높은 생성/종료 비용
    - 프로세스 생성 시 메모리 매핑, PCB 초기화 등 복잡한 과정
    - 컨텍스트 스위칭 비용 높음
    - 시스템 자원 할당/해제 오버헤드 발생

**멀티스레드**

**개념**

- 단일 프로세스 내 multiple 실행 흐름 생성
- 스레드 간 메모리 공간 공유
- 경량화된 병렬 처리 단위

**장점**

1. 자원 공유 효율
    - 같은 프로세스 내 메모리 영역 직접 공유
    - 전역 변수, 힙 메모리 공통 접근
    - 불필요한 메모리 중복 방지
2. 빠른 통신
    - 공유 메모리로 인한 직접적인 데이터 교환
    - 스레드 간 컨텍스트 스위칭 오버헤드 최소화

**단점** 

1. 동기화 복잡성
    - 공유 자원 동시 접근 시 경쟁 조건 발생
    - 뮤텍스, 세마포어 등 복잡한 동기화 메커니즘 필요
    - 교착 상태(Deadlock) 위험성
2. 안정성 
    - 한 스레드 오류 시 전체 프로세스에 영향
    - 메모리 공간 공유로 인한 취약성
    - 디버깅 및 예외 처리 어려움

**실용적 비교**

**사용 시나리오**

- 멀티프로세스:높은 격리성 요구 시, 안정성 중요한 시스템, 독립적 작업 처리
- 멀티스레드:빠른 작업 전환 필요 시, 자원 효율성 중요한 경우, 긴밀한 작업 연계 요구 시

---

## 6. 멀티프로그래밍의 목적

CPU 활용도를 최대화하고 시스템 처리량을 높이기 위해 여러 프로세스를 동시에 메모리에 적재하여 실행합니다. 한 프로세스가 대기 상태일 때 다른 프로세스에 CPU를 할당함으로써 자원 효율성을 증대시킵니다.

---

## 7. PCB(Process Control Block)란?

PCB는 프로세스에 대한 모든 정보를 관리하는 커널의 자료구조로, 다음 정보를 포함합니다:
• 프로세스 상태
• 프로그램 카운터
• CPU 레지스터 값
• CPU 스케줄링 정보
• 메모리 관리 정보

**PCB 존재 이유**

1. 프로세스 상태 추적
    - 프로세스의 현재 상태를 정확히 관리
    - 컨텍스트 스위칭 시 필수적인 정보 제공
    - 시스템 자원 할당/해제 결정
2. 효율적인 멀티태스킹
    - 여러 프로세스 동시 관리
    - 신속한 프로세스 전환
    - 스케줄링 알고리즘 지원
3. 시스템 자원 추적
    - 각 프로세스에 할당된 자원 관적
    - 자원 사용 모니터링
    - 충돌 방지 및 공정한 자원 분배
4. 컨텍스트 스위칭 지원
    - 프로세스 중단/재개 시 필요한 모든 정보 보관
    - CPU 레지스터, 메모리 상태 즉시 복원 가능
    - 최소한의 오버헤드로 신속한 프로세스 전환

---

## 8. 컨텍스트 스위칭(Context Switching) 심층 분석

### 기본 개념

컨텍스트 스위칭은 CPU가 한 프로세스에서 다른 프로세스로 제어권을 이전하는 과정입니다.

### 상세 메커니즘

### 수행 절차

1. 현재 실행 중인 프로세스 상태 저장
    - 현재 프로세스 PCB에 레지스터 값 보관
    - 프로그램 카운터, CPU 상태 등 저장
2. 다음 프로세스 선택
    - 스케줄러가 다음 실행할 프로세스 결정
    - 준비 상태의 프로세스 중 선택
3. 새로운 프로세스 상태 복원
    - 선택된 프로세스의 PCB에서 저장된 정보 로드
    - 레지스터, 메모리 매핑 정보 복원

### 오버헤드 발생 원인

- PCB 정보 저장/복원 시간
- 레지스터 값 교체
- 메모리 매핑 변경

### 컨텍스트 스위칭 유형

1. 프로세스 간 스위칭
    - 완전히 다른 프로세스 간 전환
    - 최대 오버헤드 발생
2. 스레드 간 스위칭
    - 같은 프로세스 내 스레드 전환
    - 최소한의 오버헤드
  
---

## 9. Zombie vs Orphan 프로세스 심층 분석

### Zombie 프로세스

### 정의

- 자식 프로세스 종료 후 종료 상태 미회수 상태
- 프로세스 테이블에 좀비 상태로 남아있음

### 발생 메커니즘

1. 자식 프로세스 실행 종료
2. exit() 시스템 콜로 종료 상태 반환
3. 부모 프로세스가 wait() 호출로 상태 회수 미실행

### 문제점

- 시스템 프로세스 테이블 자원 점유
- 메모리 누수 가능성
- 프로세스 자원 해제 지연

### 해결 방법

- 부모 프로세스에서 wait() 시스템 콜 사용
- 시그널 핸들링
- 좀비 프로세스 주기적 제거

### Orphan 프로세스

### 정의

- 부모 프로세스 먼저 종료
- init 프로세스(PID 1)의 자식으로 입양

### 발생 메커니즘

1. 부모 프로세스 비정상 종료
2. 자식 프로세스 고아 상태 전환
3. init 프로세스가 입양

### 문제점

1. 부모 프로세스 부재로 자원 관리 불가능
2. init 프로세스에 의존적인 자원 관리
3. 시스템 리소스 비효율적 점유
4. 프로세스 제어 메커니즘 상실

### 해결 방법

1. 부모 프로세스 종료 전 자식 프로세스 처리
    - 자식 프로세스에 명시적 종료 신호 전달
    - kill() 시스템 콜 활용
2. 시그널 핸들링
    - SIGTERM, SIGKILL 등 시그널로 프로세스 관리
    - 강제 종료 및 자원 해제
3. 사전 예방적 프로세스 관리
    - 불필요한 백그라운드 프로세스 최소화
    - 명시적이고 통제된 프로세스 생성
