# 운영체제 멀티쓰레딩 정리

## 1. 멀티 쓰레딩의 이점

멀티 쓰레딩의 주요 이점은 다음과 같습니다:

* 자원 공유의 효율성: 같은 프로세스 내 쓰레드들은 코드, 데이터 섹션을 공유하여 메모리 사용량 감소
* 응답성 향상: UI 쓰레드와 작업 쓰레드를 분리하여 사용자 인터페이스의 반응성 개선
* 경제성: 프로세스 생성보다 쓰레드 생성/컨텍스트 스위칭 비용이 훨씬 적음
* 확장성: 멀티프로세서나 멀티코어 시스템에서 병렬성 활용 가능

## 2. 싱글 코어와 멀티코어 프로그래밍에서 멀티쓰레딩의 차이점

### 싱글 코어에서의 멀티쓰레딩
1. 동시성(Concurrency) 기반 동작
   - CPU 시분할 방식으로 쓰레드들을 번갈아 실행
   - 실제로는 한 번에 하나의 쓰레드만 실행되지만, 빠른 컨텍스트 스위칭으로 동시에 실행되는 것처럼 보임
   - 진정한 병렬 처리는 불가능

**장점:**
- I/O 작업 시 CPU 유휴 시간 활용 가능
- 응답성 향상 (UI 쓰레드가 블로킹되지 않음)
- 자원 공유 효율성

**단점:**
- 컨텍스트 스위칭 오버헤드
- 실제 성능 향상에 제한적

### 멀티 코어에서의 멀티쓰레딩
1. 병렬성(Parallelism) 실현
   - 여러 쓰레드가 실제로 동시에 실행 가능
   - 각 코어가 독립적으로 쓰레드 실행
   - 진정한 의미의 병렬 처리 구현

**장점:**
- 실제 성능 향상 가능
- CPU 집약적 작업의 처리 속도 향상
- 더 효율적인 자원 활용

**단점:**
- 동기화 메커니즘 필요성 증가
- 데이터 경쟁 조건 발생 가능성
- 디버깅 복잡도 증가

## 3. 암달의 법칙

프로그램의 병렬화를 통한 성능 향상의 한계를 수학적으로 설명한 법칙입니다.

**운영체제에서 가지는 의미:**
- 병렬화의 현실적 한계 이해
- 효율적인 리소스 활용 계획 수립
- 비용 효율적인 시스템 설계 가능

## 4. User Thread와 Kernel Thread의 차이점

### User Thread:
- 사용자 수준에서 관리
- 커널 지원 없이 관리되어 빠름
- OS가 인식하지 못해 실제 병렬처리 불가

### Kernel Thread:
- 커널이 직접 관리
- 컨텍스트 스위칭 비용이 크지만 실제 병렬 처리 가능
- OS 스케줄러에 의해 직접 스케줄링

## 5. Implicit Threading

### Implicit Threading의 개념
- 스레드의 생성과 관리 책임을 개발자가 아닌 컴파일러와 런타임 라이브러리에 위임
- 개발자는 병렬 실행 가능한 작업만 식별하여 함수로 작성
- 시스템이 스레드 관리를 담당하고, 애플리케이션은 라이브러리를 통해 작업 매핑만 수행

### 주요 구현 방식

#### 1. Thread Pool
- **목적:** 무분별한 스레드 생성 방지
- **동작 방식:**
  - 프로세스 시작 시 고정된 수의 스레드 미리 생성
  - 요청이 오면 유휴 스레드에 작업 할당
  - 모든 스레드가 사용 중이면 대기열에서 대기

#### 2. Fork-Join
- **동작 방식:**
  - 부모 스레드가 작업을 fork(분할)
  - 자식 스레드들이 병렬 처리
  - 작업 완료 후 join(결합)으로 결과 통합
- **특징:**
  - 개발자가 직접 스레드 생성하지 않음
  - 라이브러리가 스레드 생성과 관리 담당
  - 동기 방식의 스레드 풀 구현

#### 3. OpenMP
- **특징:** 공유 메모리 환경의 병렬 처리 지원
- **구현 방식:**
  - 컴파일러 지시어(#pragma) 사용
  - 시스템 코어 수에 따른 자동 스레드 생성
  - for문 등의 병렬 처리 자동화

### 장단점
**장점:**
- 개발자의 스레드 관리 부담 감소
- 시스템 자원의 효율적 활용
- 높은 수준의 추상화 제공

**단점:**
- 세밀한 제어가 어려움
- 디버깅이 복잡
