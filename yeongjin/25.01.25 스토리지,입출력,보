### Q1: 디스크 스케줄링 목적
- 디스크 헤드의 접근 시간(seek time) 최소화
- 데이터 전송 대역폭(bandwidth) 최대화

### Q2: 스케줄링 알고리즘
- FCFS: 요청이 들어온 순서대로 처리. 단순하지만 성능이 좋지 않음
- SCAN: 엘리베이터처럼 양방향으로 이동하며 처리. 기아 현상 방지
- C-SCAN: 한 방향으로만 이동하며 처리하고 반대편으로 돌아갈 때는 요청 처리하지 않음

### Q3: RAID
목적: 성능 향상과 데이터 신뢰성 제고
- RAID 0: 데이터를 여러 디스크에 분산 저장(Striping)
- RAID 1: 데이터를 복제(Mirroring)

### Q4: RAID 4 vs RAID 5
- RAID 4: 패리티 정보를 별도 디스크에 저장
- RAID 5: 패리티 정보를 모든 디스크에 분산 저장
- RAID 5 선호 이유: 병목현상 해결, 효율적 공간 사용

### Q5: 디렉토리 레벨 비교
단일 레벨:
- 장점: 구현 간단
- 단점: 파일명 중복 불가, 다중 사용자 환경 부적합

이중 레벨:
- 장점: 사용자별 독립적 파일명
- 단점: 그룹 파일 공유 어려움

### Q6: 디렉토리 구조 비교
트리 구조:
- 계층적 구조로 효율적 관리
- 그룹 작업 용이
- 단순 경로만 가능

비순환 그래프:
- 디렉토리 공유 가능
- 중복 저장 방지
- 다중 경로 접근
- 복잡한 삭제 처리

### Q7: 연속 할당 방식
장점:
- 구현 단순
- 빠른 접근 속도
- 최소 헤드 이동

단점:
- 외부 단편화
- 크기 변경 어려움
- 초기 크기 예측 필요

### Q8: 폴링 vs 인터럽트
폴링:
- CPU의 주기적 상태 확인
- 장점: 단순 구현, 예측 가능
- 단점: CPU 낭비, 느린 응답

인터럽트:
- 장치의 CPU 신호 전송
- 장점: CPU 효율성, 실시간 응답
- 단점: 복잡한 구현, 스위칭 오버헤드

### Q9: DMA
동작 원리:
- CPU 무관한 메모리-I/O 직접 전송
- DMA 컨트롤러 관리

장점:
- CPU 부하 감소
- 높은 전송률
- 시스템 효율성

### Q10-Q11: I/O 유형
블로킹 I/O:
- I/O 완료까지 대기
- 쉬운 동기화, 낮은 자원 활용

논블로킹 I/O:
- 즉시 리턴
- 높은 응답성/자원 활용

비동기 I/O:
- 완료 시 통지
- 높은 처리량
- 복잡한 구현

### Q12-Q13: Memory-Mapped I/O
구성요소:
1. 데이터 입력 레지스터
2. 데이터 출력 레지스터
3. 상태 레지스터
4. 제어 레지스터

장점:
- 별도 I/O 명령어 불필요
- 단순한 프로그래밍
- 쉬운 드라이버 작성

단점:
- 메모리 주소 공간 점유
- 캐시 일관성 문제
- 보안 위험

### Q14: CIA 트라이애드
1. 기밀성(Confidentiality)
2. 무결성(Integrity)
3. 가용성(Availability)

### Q15: 보안 4계층
1. 물리적 보안: 물리적 접근 통제
2. 네트워크 보안: 통신/접근 제어
3. OS 보안: 시스템 레벨 보안
4. 애플리케이션 보안: 응용 프로그램 보안

### Q16: DoS vs DDoS
차이점:
- DoS: 단일 소스 공격
- DDoS: 분산 소스 공격

대응:
- 트래픽 필터링
- 부하 분산
- 방화벽 설정
- 블랙홀 라우팅

### Q17: 암호화 방식
대칭키:
- 단일 키 사용
- 빠른 처리
- 어려운 키 관리

비대칭키:
- 키 쌍 사용
- 쉬운 키 배포
- 느린 처리
- 디지털 서명

### Q18: 악성 소프트웨어
1. 바이러스: 프로그램 감염
2. 웜: 네트워크 전파
3. 트로이 목마: 위장 프로그램
4. 랜섬웨어: 데이터 암호화
5. 스파이웨어: 정보 수집

### Q19: AI 보안
활용:
- 실시간 탐지
- 이상 행동 감지
- 자동화 대응
- 예측적 분석

과제:
1. 적대적 공격 대응
2. AI 모델 보안
3. 데이터 프라이버시
4. 오탐지 관리
5. 윤리적 고려사항

