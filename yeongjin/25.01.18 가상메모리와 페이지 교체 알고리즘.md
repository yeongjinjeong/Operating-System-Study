# 운영체제 면접 질문 정리

## 가상 메모리

**Q: 가상 메모리의 개념과 장단점을 설명해주세요.**

가상 메모리는 실제 물리적 메모리보다 더 큰 메모리를 사용할 수 있게 해주는 메모리 관리 기법입니다. 프로세스 전체가 메모리에 올라가지 않더라도 실행이 가능하도록 하는 기술입니다.

### 장점:
- 더 큰 프로그램을 실행 가능하게 함
- 메모리 파편화 문제 해결
- 프로세스간 메모리 보호 기능 제공
- 다중 프로그래밍 환경에서 더 많은 프로그램 동시 실행 가능

### 단점:
- 페이지 테이블 관리를 위한 추가 메모리 필요
- 주소 변환 시 오버헤드 발생
- 하드웨어적 지원 필요

---

## Demand Paging

**Q: Demand Paging의 동작 방식과 장점을 설명해주세요.**

### Demand Paging의 개념

Demand Paging은 프로세스 실행 시 필요한 페이지만 메모리에 적재하는 가상 메모리 관리 기법입니다. 프로그램 전체를 한번에 메모리에 올리지 않고, 실제로 필요한 페이지만 선택적으로 적재합니다.

### 동작 과정

**초기 상태**
- 프로세스 시작 시 페이지 테이블만 생성
- 모든 페이지는 처음에 Invalid로 마킹
- Valid/Invalid 비트로 페이지 존재 여부 확인

**페이지 요청 처리**
1. CPU가 페이지 테이블 확인
2. 페이지가 없으면 Page Fault 발생
3. OS가 디스크에서 해당 페이지 위치 확인
4. 빈 프레임에 페이지 로드
5. 페이지 테이블 업데이트
6. 중단되었던 명령어 재실행

### 장점
- 메모리 사용량 최소화
- I/O 작업량 감소
- 빠른 프로그램 로딩 시간
- 더 많은 프로세스 수용 가능
- 시스템 자원의 효율적 사용

### 단점
- Page Fault 처리를 위한 추가 시간 소요
- 페이지 테이블 관리를 위한 추가 메모리 필요
- 시스템 복잡도 증가
- 초기 실행 시 Page Fault 다수 발생

### Pure Demand Paging vs Prepaging

**Pure Demand Paging**
- 정말 필요한 페이지만 메모리에 로드
- 메모리 사용량은 최소화되나 초기 Page Fault 다수 발생

**Prepaging**
- 예상되는 페이지를 미리 메모리에 로드
- 메모리 사용량은 증가하나 Page Fault 감소

---

## Page Fault

**Q: Page Fault가 발생하는 과정과 처리 방법을 설명해주세요.**

Page Fault는 프로세스가 접근하려는 페이지가 메모리에 없을 때 발생하는 인터럽트입니다.

### 처리 과정:
1. CPU가 페이지 테이블 확인
2. 페이지가 없으면 (invalid bit) 페이지 폴트 인터럽트 발생
3. 운영체제가 디스크에서 해당 페이지 위치 확인
4. 빈 프레임이 있으면 해당 프레임에, 없으면 페이지 교체 알고리즘으로 희생 페이지 선정
5. 디스크에서 페이지를 읽어 메모리에 적재
6. 페이지 테이블 업데이트 (valid bit 설정)
7. 중단되었던 명령어 재실행

---

## 페이지 교체 알고리즘

### FIFO (First-In-First-Out)

**Q: FIFO 알고리즘의 작동 방식과 Belady's Anomaly에 대해 설명해주세요.**

FIFO는 가장 오래된 페이지를 교체하는 가장 단순한 알고리즘입니다.

#### 동작 과정:
1. 페이지들을 큐로 관리
2. 새로운 페이지는 큐의 끝에 추가
3. 교체 필요시 큐의 앞에 있는 가장 오래된 페이지 제거

#### 장점:
- 구현이 단순하고 이해하기 쉬움
- 적은 오버헤드
- 예측 가능한 동작

#### 단점:
- Belady's Anomaly 발생 (프레임 수를 늘려도 페이지 폴트가 증가하는 현상)
- 페이지의 사용 빈도나 중요도를 고려하지 않음
- 자주 사용되는 페이지가 교체될 수 있음

### OPT (Optimal)

**Q: OPT 알고리즘이 최적인 이유와 실제 구현이 불가능한 이유는 무엇인가요?**

OPT는 가장 오랫동안 사용되지 않을 페이지를 교체하는 이론적으로 최적의 알고리즘입니다.

#### 동작 방식:
1. 각 페이지의 미래 참조 시점 확인
2. 가장 나중에 참조될 페이지 선택
3. 선택된 페이지를 교체

#### 장점:
- 최소의 페이지 폴트 발생
- 다른 알고리즘의 성능 비교 기준으로 사용
- Belady's Anomaly가 발생하지 않음

#### 단점:
- 미래의 페이지 참조를 예측해야 하므로 실제 구현 불가능
- 높은 계산 비용
- 실시간 시스템에서 사용 불가

### LRU (Least Recently Used)

**Q: LRU 알고리즘의 구현 방식과 효율성에 대해 설명해주세요.**

LRU는 가장 오래전에 사용된 페이지를 교체하는 알고리즘입니다.

#### 동작 방식:
1. 각 페이지의 마지막 참조 시간 기록
2. 페이지 교체 필요시 가장 오래전에 참조된 페이지 선택
3. 페이지 참조시마다 시간 정보 업데이트

#### 장점:
- 시간 지역성 활용으로 효율적인 성능
- Belady's Anomaly 발생하지 않음
- 실제 메모리 접근 패턴 반영

#### 단점:
- 참조 시간 기록을 위한 하드웨어 지원 필요
- 구현이 복잡
- 시간 정보 관리를 위한 오버헤드 발생

### Second-Chance Algorithm

**Q: Second-Chance 알고리즘의 작동 방식과 FIFO와의 차이점은 무엇인가요?**

Second-Chance는 FIFO를 개선한 알고리즘으로, 참조 비트를 활용해 페이지에 두 번째 기회를 제공합니다.

#### 동작 방식:
1. 각 페이지에 참조 비트(reference bit) 할당
2. 페이지 접근시 참조 비트를 1로 설정
3. 교체 시 FIFO 순서로 검사하되, 참조 비트가 1이면 0으로 바꾸고 두 번째 기회 제공
4. 참조 비트가 0인 페이지를 찾을 때까지 계속 검사

#### 장점:
- FIFO보다 향상된 성능
- 구현이 비교적 단순
- 최근 사용된 페이지 보호

#### 단점:
- FIFO보다 약간의 오버헤드 발생
- 참조 비트 관리 필요
- 하드웨어 지원 필요

---

## Thrashing

**Q: Thrashing의 발생 원인과 해결 방법을 설명해주세요.**

Thrashing은 프로세스의 작업 집합보다 할당된 프레임이 적을 때 발생하는 성능 저하 현상입니다.

### 원인:
- 프로세스에 할당된 프레임 수 부족
- 과도한 페이지 교체 발생
- 실제 작업보다 페이징에 더 많은 시간 소요

### 해결 방법:
- 작업 집합 크기에 맞는 충분한 프레임 할당
- 다중 프로그래밍 정도 조절
- 페이지 폴트 빈도 모니터링
- 프로세스당 최소 프레임 수 보장
