# CPU 스케줄링
> Ready에 있는 스레드들 중 하나를 선택하여 CPU를 할당하는 과정
* 오늘날 운영체제에서 실행 단위가 스레드이므로 CPU 스케줄링은 스레드를 대상으로 한다.

#### 작업 스케줄링(job scheduling)
* 메모리에 적재된 프로세스가 종료하면 디스크에서 기다리는 작업 중 하나를 선택하여 메모리에 적재하는 과정
#### CPU 스케줄링
* 실행중인 프로세스가 I/O를 실행할 때 메모리에 적재된 다른 프로세스 중 CPU에 실행시킬 프로세스를 선택하는 과정

##### CPU burst
* 프로그램 실행 과정에서 CPU가 코드를 집중적으로 실행하는 상황
* CPU burst시간이 절대적으로 많으면 CPU intensive 프로세스라 한다. 
##### I/O burst
* I/O 장치에 의해 입출력이 이루어지는 상황
* I/O burst시간이 절대적으로 많으면 I/O intensive 프로세스라 한다.
> I/O burst 시간 동안 CPU 유휴시간을 줄이기 위해 CPU를 다른 프로세스에게 할당하는 CPU 스케줄링 도입

### CPU 스케줄링의 기본 목표
* CPU 활용률 향상
* 컴퓨터 시스템 처리율 향상

### CPU 스케줄링의 기준 : 컴퓨터 시스템의 목표에 따라 다를 수 있다. 
* CPU 활용률(utilization) : 컴퓨터 전체 가동 시간에 대한 CPU 사용 시간의 비율
* 처리율(throughput) : 단위 시간 당 처리하는 스레드의 개수
* 공평성(fairness) : 모든 스레드에게 CPU 사용 시간을 공평하게 배분하는 것
* 응답시간(response time) : 사용자에 대한 응답 시간 최소화
* 대기시간(waiting time) : 스레드가 준비 리스트에서 CPU를 할당받을 때까지 기다리는 시간
* 소요시간(turnaround time) : 작업이 컴퓨터 시스템에 진입하는 시점에서 완료까지 걸린 시간
  - batch 시스템에서는 작업이 제출된 시점부터 결과가 반환될 때까지 걸린시간
  - 다중프로그래밍 시스템에서는 프로세스가 시작되어 종료될 때까지 걸린 시간
* 시스템 정책 우선 (high policy enforcement) : CPU 스케줄링이 시스템의 정책에 맞도록 이루어져야함
   - ex) 보안 중심 시스템에서 보안쳌 스레드가 사용자 스레드보다 더 높은 우선순위를 가져야한다.
* 자원 활용률(high resource efficiency) : CPU나 I/O 장치 등 자원이 놀지 않도록 자원 활용률을 극대화하는 것

### 타임 슬라이스(time slice)
* 스레드가 CPU 사용을 보장받는 시간, 커널이 CPU 스케줄링을 하는 주기
* 대부분의 운영체제들은 하나의 스레드가 CPU 독점하는 것을 허용하지 않는다.
* 커널은 타이머의 도움을 받아 타임슬라이스가 되면 스레드 강제 중단(preemption) 준비 리스트에 삽입 다른 스레드 선택
----------------------


# CPU 스케줄링 기본

### CPU 스케줄링이 실행되는 4가지 상황
1. 스레드가 I/O를 요청하는 시스템 호출 실행하거나 자원을 기다리는 등 블록(blocked) 상태가 될때
2. 스레드가 자발적으로 CPU 반환하는 경우
3. 스레드에게 할당된 타임 슬라이스가 다 소진되어 타이머 인터럽트 발생할 때
4. 현재 실행 중인 스레드보다 높은 순위의 스레드가 요청한 입출력이 완료되어 I/O 인터럽트가 발생한 경우

### 비선점(non-preemptive)과 선점형(preemptive) 스케줄링

#### 비선점 스케줄링
* 스레드가 CPU를 할당받아 일단 실행하면 완료되거나 CPU를 더 이상 사용할 수 없는 상황이 될 때까지 CPU를 사용한다.
 - CPU를 더 이상 사용할 수 없게 된 경우: I/O로 인한 블록 상태, sleep()
 - 자발적 CPU 양보 : yield()
 - 스레드 종료
> 범용에서 사용되지 않고 실시간 처리가 필요한 임베디드에서 주로 사용
#### 선점 스케줄링
* 스레드가 종료,자발적으로 양보, 블록 당하는 경우 외에도 실행중인 스레드를 강제로 중단시켜 준비 리스트로 보내고 스케줄링
    - 타임 슬라이스가 소진되었을때
    - 인터럽트나 시스템 호출 종료 시점에서 더 높은 순위의 스레드가 대기 상태에 있을 때
> 대부분의 운영체제는 선점 스케줄링

#### 기아(starvation)와 에이징(aging)
* 기아: 스케줄링 과정에서 선택되지 못한 채 오랜 시간 동안 준비 리스트에 있는 상황
* 에이징: 스레드가 준비 리스트에 머무르는 시간에 비례하여 우선순위를 높여주어 기아 문제를 해결하는 방법
-------

# CPU 스케줄링 알고리즘

1. FCFS(First Come First served)
   * 큐에 먼저 도착한 스레드를 먼저 스케줄링
   * 비선점 : 먼저 도착한 스레드가 실행 마쳐야 다음 스레드 실행
   * 우선순위 없음 : 먼저 온 스레드 실행
   * 기아 발생안함
   * 처리율이 낮지만 단순하여 구현 용이
   > 긴 cpu burst를 가진 스레드가 cpu를 양도할 때가지 늦게 도착한 짧은 스레드들이 오래 대기(Convoy Effect)

2. SJF(shortest Job First)
   * 실행 시간이 가장 짧은 스레드를 먼저 실행
   * 비선점 : 선택된 스레드가 실행을 끝날 때까지 중단시키지 않는다
   * 기아 발생 가능 : 짧은 실행 시간을 가진 스레드가 계속 큐에 도착하면 긴 스레드에 기아 발생
   * 평균 대기 시간 최소화
   > 스레드의 실행 시간을 예측하기 어렵기 때문에 현실에서 사용하기 어렵다.

3. SRTF(shortest reamining Time First)
  * SJF의 선점 스케줄링 버전으로 남은 실행 시간이 가장 짧은 스레드를 우선 스케줄
  * 선점
  * 기아 발생 가능 : 짧은 실행 시간 스레드가 지속적으로 큐에 도착하면 긴 스레드 기아 발생
  * 평균 대기 시간은 최소화
> 스레드의 실행 시간 예측이 어려워 현실에서는 사용되기 어렵다.

4. RR(Round-Robin)
   * 공평한 실행기회를 주어 타임 슬라이스 주기로 돌아가면서 선택
   * 선점 : 타임 슬라이스가 지나면 강제 중단 시켜 대기 큐에 삽임
   * 기아 발생 없음
   * 구현이 쉽지만 잦은 스케줄링으로 인해 컨텍스트 스위칭에 소요되는 시간이 많다.
5. priority 스케줄링
   * 큐에서 가장 높은 우선순위의 스레드를 선택
   * 스레드마다 고정 우선순위 값을 가진다.
   * 선점/비선점 모두 가능
   * 기아 발생 가능 : 우선 순위 높은 스레드가 큐에 많이 도착하면
   * 높은 스레드의 대기 시간이나 응답 시간이 짧다.
   > 주로 고정 우선순위를 가지는 실시간 시스템에서 사용된다.
6. MLQ (Multi-level Queue)
   * n개의 우선순위 레벨로 구분(n개의 큐), 레벨이 높은 스레드를 우선 처리
   * 선점/ 비선점 모두 가능
   * 기아 발생 가능 : 지속적으로 높은 레벨의 스레드가 도착하면 기아 발생
   * 고정 우선순위를 가진다 (n 레벨 중 하나)
   * 높은 순위를 가진 스레드들의 대기 시간이나 응답 시간이 짧다.
     > 스레드별 고정 우선순위를 두고 높은 순위의 스레드를 먼저 실행시키는 시스템에서 아용
7. MLFQ (Multi-level Feedback Queue)
   * cpu burst가 짧은 스레드나 I/O 작업이 많은 스레드, 대화식 스레드를 우선 실행시켜 평균 대기시간을 감소
   * 사용자의 응답 시간을 짧게하고 기아 발생 안한다. 구현에 따라 다를 수도 있지만 책 설명은 RR과 MLQ를 섞어서 구현한다.
   * n개의 레벨 큐 
     - 도착 스레드 가장 높은 레벨 큐에 삽입
     - 가장 높은 레벨 큐에서 스레드 선택, 비었으면 아래 레벨 큐 실행
     - cpu burst가 타임 슬라이스보다 길어지면 중단하고 아래 레벨 큐로 이동
     - 자발적 중단이나 I/O요청하면 동일한 큐로 다시 삽입된다.
     - 큐에서 대기하는 시간이 오래되면 한 레벨 위의 큐로 이동시킨다.
   * 선점형 
   * 기아 발생 안한다 : 스레드가 낮은 레벨 큐에서 너무 오랜 시간 대기하면 하나 높은 레벨의 큐로 이동(aging)
     - 큐 개수가 많거나 퐁느 레벨의 큐에 스레드가 많으면 오래 기달릴 수도 있다.
   * cpu burst가 짧거나 입출력이 빈헌한 스레드, 대화식 스레드에게 높은 우선순위부여해 평균 대기 시간 줄인다.
   * 유연성이 좋지만 알고리즘 복잡 cpu의 오버헤드 증가
------------------------
# 멀티 코어에서 CPU 스케줄링과 작업 분배 문제

### 컨텍스트 스위칭 후 오버헤드
 * 새 스레드를 실행할 때 새 스레드의 코드와 데이터가 캐시에 적재되는 시간이 소요된다.
> 코어 친화성(core affinity)으로 해결 : 스레드를 동일한 코어에서만 계속 실행되도록 스케줄한다. (CPU affinity,CPU pinning, cache affinity) 다 같은 뜻이다.

> 보통 프로세스가 특정 코어에 친화성을 가지면 속한 스레드들도 그 코어에서 실행되도록 스케줄링한다.

### 코어별 부하 불균형
* 어떤 코어는 많은 스레드를 실행하고 어떤 코어는 작은 수의 스레드 실행하는 불균형
* 부하가 많은 코어 대기 시간과 처리 시간 길어져 처리율 감소
### 부하 균등화 기법(load balancing)
1. 푸시 마이그레이션 기법(push migration) : 스레드 큐를 감시하는 별도의 감시 스레드 생성, 실행할 스레드가 없는 코어가 생길때 스레드를 강제로 옮기는 기법
2. 풀 마이크레이션(pull migration) : 코어는 처리할 스레드가 없게 될 때 다른 코어의 스레드 큐에서 스레드를 가져와 자신의 스레드 큐에 넣고 실행.
