# 저장장치 관리 (Storage Management)

## 대용량 저장장치 (Mass Storage)

대용량 저장장치는 컴퓨터의 비휘발성 2차 저장장치 시스템으로, 주로 HDD(Hard Disk Drive)나 NVM(Non-Volatile Memory)을 사용합니다. 때로는 자기 테이프, 광학 디스크, 클라우드 저장소 등도 포함됩니다.

### 하드 디스크 드라이브(HDD) 구조

HDD는 다음과 같은 구성요소를 가집니다:
- 플래터(Platter): 실제 데이터가 저장되는 원판
- 스핀들(Spindle): 플래터를 회전시키는 축
- 헤드(Head): 데이터를 읽고 쓰는 장치
- 암(Arm): 헤드를 이동시키는 장치
- 트랙(Track): 플래터 위의 동심원
- 섹터(Sector): 트랙의 일부분
- 실린더(Cylinder): 여러 플래터의 같은 위치에 있는 트랙들의 집합

### HDD 스케줄링

디스크 스케줄링의 주요 목적:
1. 접근 시간(seek time) 최소화
2. 데이터 전송 대역폭(bandwidth) 최대화

주요 스케줄링 알고리즘:

#### FCFS (First Come First Served)
- 가장 단순한 방식으로 요청이 들어온 순서대로 처리
- 공평하지만 성능이 좋지 않음
- 헤드 이동 거리가 길어질 수 있음

#### SCAN
- 엘리베이터 알고리즘이라고도 불림
- 헤드가 한쪽 끝에서 다른 쪽 끝으로 이동하면서 처리
- 진행방향에 있는 요청들을 처리하고 끝에 도달하면 방향을 바꿈
- 장점: 기아 현상 방지
- 단점: 중간 지점의 요청들의 대기 시간이 길어질 수 있음

#### C-SCAN (Circular SCAN)
- SCAN의 변형
- 한쪽 방향으로만 요청을 처리
- 반대쪽으로 돌아갈 때는 요청을 처리하지 않음
- 더 균일한 대기 시간 제공



## 3. RAID (Redundant Arrays of Independent Disks)
- 여러 개의 디스크를 배열로 구성하여 사용하는 기술
- 성능 향상과 신뢰성 제고가 주요 목적

### 주요 RAID 레벨

#### RAID 0 (Striping)
- 데이터를 여러 디스크에 분산 저장
- 성능 향상
- 중복성 없음 (신뢰성 낮음)

#### RAID 1 (Mirroring)
- 모든 데이터를 두 개 이상의 디스크에 복제
- 높은 신뢰성
- 저장 공간 효율성 낮음

#### RAID 4
- 패리티 정보를 별도 디스크에 저장
- 디스크 하나 고장 시 복구 가능
- 패리티 디스크가 병목현상 유발 가능

#### RAID 5
- 패리티 정보를 모든 디스크에 분산 저장
- RAID 4의 병목현상 해결
- 가장 널리 사용되는 RAID 레벨

#### RAID 6
- 이중 패리티 사용
- 두 개의 디스크 동시 고장에도 복구 가능
- 쓰기 성능 다소 저하

### RAID의 주요 특징

1. 병렬성 향상
- 여러 디스크 동시 접근 가능
- 데이터 전송률 향상
- 응답시간 감소

2. 신뢰성 향상
- 중복 저장으로 인한 데이터 보호
- 디스크 고장 시 복구 가능
- 시스템 가용성 향상

3. 비용 효율성
- 저렴한 소형 디스크 활용
- 용량 확장 용이
- 유지보수 편리

### RAID 구현 방식

1. 하드웨어 RAID
- 전용 컨트롤러 사용
- 성능이 우수
- 비용이 높음

2. 소프트웨어 RAID
- OS에서 구현
- 구현이 유연함
- CPU 부하 발생

## 4. 파일 시스템 (File System)
* 파일 시스템은 컴퓨터에서 파일이나 데이터를 쉽게 발견 및 접근할 수 있도록 보관 또는 조직하는 체계입니다.

### 파일 접근 방식

#### 순차 접근 (Sequential Access)
- 테이프 모델에 기반
- 현재 위치에서부터 순서대로 읽거나 쓰기
- 뒤로 돌아가려면 처음부터 다시 읽어야 함
- 장점: 구현이 단순, 테이프 같은 순차 매체에 적합
- 단점: 임의 접근이 어려움

#### 직접 접근 (Direct Access)
- 레코드 단위로 임의 접근 가능
- 디스크 기반 저장장치에 적합
- 장점: 빠른 접근 속도, 효율적인 공간 활용
- 단점: 구현이 복잡함

### 디렉토리 구조

#### 단일 레벨 디렉토리 (Single-Level Directory)
- 모든 파일이 하나의 디렉토리에 존재
- 구현이 간단
- 파일명 중복 불가
- 여러 사용자 환경에서 부적합

#### 이중 레벨 디렉토리 (Two-Level Directory)
- 사용자별로 별도의 디렉토리 제공
- 다른 사용자와 같은 파일명 사용 가능
- 그룹 단위의 파일 공유가 어려움

#### 트리 구조 디렉토리 (Tree-Structured Directory)
- 계층적 구조
- 효율적인 파일 관리 가능
- 그룹 작업 용이
- 경로 탐색의 오버헤드 존재

#### 비순환 그래프 디렉토리 (Acyclic-Graph Directory)
- 디렉토리 공유 가능
- 파일의 중복 저장 방지
- 삭제 시 처리가 복잡
- 가비지 컬렉션 필요

### 4.4 파일 할당 방식

#### 연속 할당 (Contiguous Allocation)
- 파일의 블록들이 디스크 상에 연속적으로 위치
- 장점:
  - 구현이 간단
  - 순차 접근이 빠름
  - 직접 접근이 용이
- 단점:
  - 외부 단편화 발생
  - 파일 크기 변경이 어려움
  - 파일 생성 시 크기 예측 필요

#### 연결 할당 (Linked Allocation)
- 각 블록이 다음 블록을 가리키는 포인터를 포함
- 장점:
  - 외부 단편화 없음
  - 파일 크기 동적 변경 용이
- 단점:
  - 직접 접근이 어려움
  - 포인터로 인한 공간 낭비
  - 신뢰성 문제 (포인터 손상)

##### FAT (File Allocation Table)
- 연결 할당의 변형
- 포인터를 별도의 테이블로 관리
- 장점:
  - 직접 접근 성능 향상
  - 신뢰성 개선
- 단점:
  - FAT 테이블을 위한 메모리 필요
  - FAT 손상 시 전체 파일시스템 영향

#### 색인 할당 (Indexed Allocation)
- 각 파일별로 인덱스 블록 사용
- 인덱스 블록에 모든 포인터 저장
- 장점:
  - 직접 접근 용이
  - 외부 단편화 없음
  - 파일 크기 동적 변경 가능
- 단점:
  - 작은 파일도 인덱스 블록 필요
  - 인덱스 블록으로 인한 공간 낭비
  - 큰 파일의 경우 여러 레벨의 인덱스 필요

### 자유 공간 관리 (Free Space Management)

#### 비트맵 (Bitmap)
- 각 블록의 할당 상태를 비트로 표시
- 장점:
  - 구현이 간단
  - 연속된 빈 블록 찾기 용이
- 단점:
  - 비트맵을 위한 추가 공간 필요

#### 연결 리스트 (Linked List)
- 빈 블록들을 연결 리스트로 관리
- 장점:
  - 추가 공간이 거의 불필요
- 단점:
  - 연속된 빈 블록 찾기 어려움

#### 그룹화 (Grouping)
- 첫 번째 빈 블록에 다른 빈 블록들의 주소 저장
- 장점:
  - 연속된 빈 블록 찾기 용이
- 단점:
  - 구현이 복잡

#### 카운팅 (Counting)
- 연속된 빈 블록의 첫 주소와 개수 저장
- 장점:
  - 연속 할당에 효율적
- 단점:
  - 빈번한 할당/해제 시 오버헤드

###  저장장치 보호
1. 비밀번호
2. 접근 제어 리스트 (ACL)
3. 기능별 권한 (읽기/쓰기/실행)
4. 사용자 그룹별 권한


##  I/O 시스템 (Input/Output Systems)

### I/O 하드웨어 구성

#### I/O 장치 유형
- 블록 장치: 정해진 크기의 블록 단위로 정보 전송 (예: 디스크)
- 문자 장치: 문자 단위로 정보 전송 (예: 키보드, 프린터)
- 네트워크 장치: 패킷 단위로 정보 전송

### I/O 제어 방식

####  폴링 (Polling)
- CPU가 주기적으로 장치의 상태를 확인
- 장점:
  - 구현이 단순
  - 예측 가능한 동작
- 단점:
  - CPU 시간 낭비
  - 실시간 응답 어려움

#### 인터럽트 (Interrupt)
- 장치가 CPU에 신호를 보내 작업 요청
- 구성:
  - 인터럽트 요청선 (IRQ)
  - 인터럽트 벡터 테이블
  - 인터럽트 서비스 루틴 (ISR)
- 장점:
  - CPU 효율성 향상
  - 실시간 응답 가능
- 단점:
  - 구현이 복잡
  - 컨텍스트 스위칭 오버헤드

#### DMA (Direct Memory Access)
- CPU를 거치지 않고 메모리와 I/O 장치 간 직접 데이터 전송
- 구성:
  - DMA 컨트롤러
  - DMA 버퍼
  - DMA 채널
- 장점:
  - CPU 부하 감소
  - 높은 데이터 전송률
- 단점:
  - 하드웨어 추가 비용
  - 메모리 접근 경쟁

### I/O 소프트웨어 계층

#### 사용자 수준 I/O 소프트웨어
- 라이브러리 함수
- 스풀링 시스템
- I/O 스트림

#### 장치 독립적 I/O 소프트웨어
- 버퍼링
- 에러 처리
- 장치 할당/해제
- 통일된 장치 인터페이스

#### 장치 드라이버
- 장치별 특수 기능 구현
- 인터럽트 처리
- 장치 초기화
- 에러 복구

#### 인터럽트 핸들러
- 인터럽트 처리 및 분배
- 우선순위 관리
- 인터럽트 마스킹

### I/O 요청 처리 유형

#### 블로킹 I/O
- I/O 완료될 때까지 프로세스 대기
- 장점:
  - 프로그래밍 모델 단순
  - 동기화 용이
- 단점:
  - 자원 활용도 저하
  - 응답성 저하

#### 논블로킹 I/O
- I/O 요청 후 즉시 리턴
- 장점:
  - 높은 응답성
  - 자원 활용도 향상
- 단점:
  - 복잡한 프로그래밍 모델
  - 완료 확인을 위한 추가 작업 필요

#### 비동기 I/O
- I/O 완료 시 통지
- 장점:
  - 높은 처리량
  - 효율적인 자원 활용
- 단점:
  - 구현 복잡도 높음
  - 디버깅 어려움

### I/O 성능 최적화

#### 버퍼링
- 속도 차이 보완
- 데이터 전송 단위 조정
- 데이터 가용성 향상

#### 캐싱
- 자주 사용하는 데이터 저장
- 접근 시간 단축
- 전송량 감소

#### 스풀링
- 출력 작업 임시 저장
- 장치 독점 시간 최소화
- 작업 스케줄링 가능

### I/O 보안

#### 접근 제어
- 권한 검사
- 장치 보호
- 자원 할당 제한

#### 입력 유효성 검사
- 데이터 무결성 확인
- 버퍼 오버플로우 방지
- 악성 입력 차단

#### 출력 필터링
- 민감 정보 보호
- 데이터 형식 검증
- 에러 처리

## Memory-Mapped I/O

### 개념
- 입출력 장치의 레지스터들을 메모리 주소 공간에 매핑하는 기법
- CPU가 일반적인 메모리 접근 명령어로 I/O 장치를 제어할 수 있게 함

### 구성요소
1. 데이터 입력 레지스터: 호스트가 입력을 읽기 위한 레지스터
2. 데이터 출력 레지스터: 호스트가 출력을 쓰기 위한 레지스터
3. 상태 레지스터: 장치의 현재 상태 정보
4. 제어 레지스터: 장치 제어를 위한 명령어 저장

### 장점
- 별도의 I/O 명령어 불필요
- 메모리 관련 모든 명령어 사용 가능
- 캐시 활용 가능
- 프로그래밍 단순화
- 디바이스 드라이버 작성 용이

### 단점
- 메모리 주소 공간 일부를 I/O에 할당해야 함
- 캐시 일관성 문제 발생 가능
- 보안 위험 가능성
