# 교착상태 (DeadLock)
* 자원을 소유한 스레드들 사이에서 각 스레드는 다른 스레드가 소유한 자원을 요청하여 모든 스레드가 무한정 대기하는 현상

### 코프만 조건(coffman condition)
1. 상호배제(mutual exclusion) - 자원은 한 번에 한 스레드에게만 할당
2. 소유하면서 대기 (Hold & wait) - 스레드가 자원을 소유하면서 다른 자원 대기
3. 강제 자원 반환 불가(No preemption) - 스레드에게 할당된 자원을 강제로 빼앗지 못함
4. 환형 대기(Circular Wait) - 한 그룹의 스레드들에게 각 스레드가 다른 스레드가 소유한 자원을 요청하는 환형 고리 형성

### 교착상태 해결 방법
1. 교착상태 예방(prevention) : 코프만 4가지 조건 중 하나 이상의 조건이 아예 성립되지 못하도록 시스템 설계
2. 교착상태 회피(avoidance) : 운영체제가 자원을 할당할때 교착상태에 빠지지 않는다고 확신할때만 할당하게 한다
3. 교착상태 감지 및 복구(detection and recovery) : 운영체제가 교착상태를 감지하는 별도의 프로그램 구동
4. 교창상태 무시(ignore and reboot) : 아무런 대비책 없이 내버려둔다. 교착상태는 왠만해선 안생기며 사용자나 관리자가 대책을 세울거다. 교착상태 있다고 파국이 아닐때


#### 교착상태 예방

1. 상호배제 없애기 : 한 자원을 동시에 2개의 스레드에게 허용. (race condition 위험)
2. 소유하면서 대기하지 않게 : 필요한 자원을 처음부터 다가지게 하거나, 새로운 자원이 필요하면 가진거 전부반납 후 필요한 자원 전부 요청
3. 자원 강제 반환 : 더 높은 우선순위의 스레드가 자원을 요청하면 낮은 순위의 스레드에게서 강제로 자원을 빼앗으면 된다. 반환된 스레드가 이전 상태 복구 필요
4. 환형 대기 제거 : 번호 순으로 자원을 할당받게 하는 방법.

#### 교착상태 회피
* 환형대기가 발생할 것인지 판단하는 작업이 필요하다.
* banker's 알고리즘이 있다. (각 스레드는 실행 전에 필요한 자원의 전체수를 운영체제에게 알려줘야한다.) 비현실적


#### 교착상태 감지 및 복구
* 자원 강제 선점 : 교착 상태의 스레드 중 하나를 강제로 반환시킨다.
* 롤백(rollback) : 교착 상태 예상 스레드들의 상태 주기적을 저장, 교착상태 발생시 최근 상태로 복구
* 스레드 강제 종료(kill process) : 교착상태에 빠른 스레드 중 하나를 강제 종료

#### 교착상태 무시 : 타조(ostrich) 알고리즘
* 교착상태 해결할 필요 있나? 적게 발생하고 교착상태 발생해도 피해가 거의 없다면?
* 교착상태가 의심되면 사용자나 관리자가 시스템을 재시작하거나 의심되는 스레드를 강제 종료
* 제일 큰 장점 : 비용(노력)이 적다.
* 큰 피해가 있을 수 있는 임베디드 시스템과 같은 곳에서는 부적절하다.


