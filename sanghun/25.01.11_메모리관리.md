# 메모리 계층 구조 (Memory Hierarchy)
개요
메모리 계층 구조는 컴퓨터 시스템에서 속도, 용량, 비용을 최적화하기 위해 여러 종류의 메모리를 계층적으로 구성한 것입니다. 상위 계층일수록 속도는 빠르지만 용량이 작고 비용이 높으며, 하위 계층으로 갈수록 속도는 느리지만 용량이 크고 비용이 낮아집니다.
주요 계층 구조
1. 레지스터 (Registers)

CPU 내부에 위치한 가장 빠른 메모리
매우 적은 용량 (수백 바이트)
접근 시간: 1 클럭 사이클 이내
CPU와 직접 데이터를 주고받는 역할

2. 캐시 메모리 (Cache Memory)

L1 캐시: CPU에 가장 가까운 캐시 (수십 KB)
L2 캐시: L1보다 큰 용량, 더 느린 속도 (수백 KB ~ 수 MB)
L3 캐시: 더 큰 용량, 더 느린 속도 (수 MB ~ 수십 MB)
SRAM(Static RAM) 사용
접근 시간: 수 나노초

3. 주기억장치 (Main Memory)

RAM(Random Access Memory)으로 구현
DRAM(Dynamic RAM) 사용
용량: 수 GB ~ 수백 GB
접근 시간: 수십 나노초
휘발성 메모리

4. 보조기억장치 (Secondary Storage)

HDD, SSD 등으로 구현
용량: 수백 GB ~ 수십 TB
접근 시간: 마이크로초 ~ 밀리초
비휘발성 메모리

## 참조의 지역성(locality of reference)
* 코드나 데이터, 자원 등이 아주 짧은 시간 내에 다시 사용되는 프로그램의 특성


### 메모리 관리 이유
1. 여러 프로세스가 사용하는 공유자원이다.
2. 메모리를 보호하기 위해. (다른 프로세스나 사용자가 함부로 이용못하게)
3. 용량 한계를 극복하기 위해서
4. 사용의 효율을 높이기 위해서

#### 물리 주소
* 실제 메모리 주소(하드웨어 주소)
#### 논리 주소
* 프로그램 내에서 사용되는 주소

### 주소 변환 하드웨어(Address Translation H/W)
* MMU(Memory Management Unit)으로 CPU 패키지 내에 구성된다.
* 논리 주소를 물리 주소로 변환한다.

## 논리 주소 사용 이유

### 1. 메모리 보호 (Memory Protection)
- 프로세스가 다른 프로세스의 메모리 영역에 접근하는 것을 방지
- 각 프로세스는 자신만의 독립된 논리 주소 공간을 가짐
- OS가 물리적 메모리 접근을 제어하여 시스템 보안 강화

### 2. 메모리 관리 유연성
- 프로그램이 연속적인 메모리 공간을 사용하지 않아도 됨
- 물리적 메모리의 파편화 문제 해결
- 메모리 할당 및 해제가 더 효율적으로 수행됨

### 3. 프로그램의 재배치성 (Relocation)
- 프로그램을 물리적 메모리의 어느 위치에나 적재 가능
- 컴파일 시점에서 실제 물리 주소를 알 필요가 없음
- 동적 로딩과 링킹이 용이

### 4. 가상 메모리 구현
- 실제 물리적 메모리보다 큰 주소 공간 사용 가능
- 필요한 부분만 물리적 메모리에 적재 (Demand Paging)
- 메모리 사용의 효율성 증가

### 5. 프로세스 독립성
- 각 프로세스는 전체 주소 공간을 독점하는 것처럼 동작
- 다른 프로세스의 존재를 인식할 필요가 없음
- 프로그래밍이 단순화됨

# 물리 메모리 할당
* 연속 메모리 할당 : 한 덩어리로 연속된 공간, 유연성 부족 홀(Hole)이 생길 수 있다.
  1. 고정 크기 할당
  2. 가변 크기 할당
* 분할 메모리 할당 : 여러 덩어리로 나누어 분산 할당하는 방법
  1. 가변 크기 할당 - 세그먼테이션(segmentation)
  2. 고정 크기 할당 - 페이징 (paging)
   
# 연속 메모리 할당 (Contiguous Memory Allocation)

## 1. 고정 분할(Fixed Partition) 방식

### 동작 방식
- 메모리를 고정된 크기의 파티션으로 미리 분할
- 각 파티션은 하나의 프로세스만 적재 가능
- 파티션 크기는 동일하거나 다를 수 있음

#### 파티션 할당 방식
- 각 프로세스를 수용 가능한 가장 작은 파티션에 할당
- 큰 파티션은 큰 프로세스를 위해 예약

### 장점
- 구현이 단순
- 메모리 할당/해제가 빠름
- 외부 단편화가 발생하지 않음

### 단점
#### 1. 내부 단편화
- 프로세스 크기가 파티션 크기보다 작을 때 발생
- 파티션 내 미사용 공간 낭비
#### 2. 메모리 사용 효율성 저하
- 프로세스가 큰 파티션을 사용할 때 공간 낭비
- 메모리 활용도 감소

## 2. 가변 분할(Variable Partition) 방식

### 동작 방식
- 프로세스 크기에 따라 필요한 만큼만 메모리 할당
- 동적으로 파티션 생성 및 제거
- 가용 공간 리스트 관리
#### 2. 가용 공간 관리
- 홀(Hole) 리스트 유지
- 인접한 가용 공간 병합
### 메모리 할당 알고리즘( 힙 메모리 관리에서 사용하기도 한다)
#### 1. First-Fit (최초 적합)
- 첫 번째 적합한 가용 공간에 할당
- 검색 시간 최소화
- 외부 단편화
#### 2. Best-Fit (최적 적합)
- 가장 크기가 비슷한 가용 공간에 할당
- 홀을 검색해야한다.
#### 3. Worst-Fit (최악 적합)
- 가장 큰 가용 공간에 할당
- 검색해야 할수있다.


### 장점
#### 1. 메모리 효율성
- 필요한 만큼만 할당
- 내부 단편화 최소화

#### 2. 유연성
- 다양한 크기의 프로세스 수용

### 단점
#### 1. 외부 단편화
- 작은 가용 공간들이 흩어져 발생
- 큰 프로세스 적재 불가능
--------
# 세크먼테이션 메모리 관리
## 세그멘테이션 (Segmentation)

### 기본 개념
- 프로그램을 논리적 단위(세그먼트)로 분할
- 각 세그먼트는 독립적인 주소 공간
- 세그먼트 크기는 가변적

### 특징
1. **논리적 분할**
   - 코드 세그먼트
   - 데이터 세그먼트
   - 스택 세그먼트
   - 힙 세그먼트
2. **보호와 공유**
   - 세그먼트 단위로 보호
   - 세그먼트 단위로 공유 가능
### 장단점
장점:
- 논리적 단위로 분할하여 이해하기 쉬움
- 보호와 공유가 용이
- 동적 크기 조절 가능
단점:
- 외부 단편화 발생
- 메모리 할당이 복잡
- 세그먼트 크기가 다양하여 메모리 관리가 어려움
-------
# 페이징 시스템 (Paging System)

### 기본 개념
- 물리 메모리를 같은 크기의 프레임(Frame)으로 분할
- 논리 메모리를 같은 크기의 페이지(Page)로 분할
- 외부 단편화 없음
- 페이지 테이블을 통해 논리 주소를 물리 주소로 변환

### 주소 변환 과정
1. CPU가 논리 주소 생성 (페이지 번호 + 오프셋)
2. 페이지 테이블에서 페이지 번호에 해당하는 프레임 번호 찾기
3. 프레임 번호와 오프셋을 조합하여 물리 주소 생성

### 페이지 테이블의 문제점
1. **큰 메모리 공간 요구**
   - 각 프로세스마다 페이지 테이블 필요
   - 32비트 시스템에서 4KB 페이지 사용 시 1M개의 PTE 필요
   - 각 PTE가 4바이트라면 프로세스당 4MB의 페이지 테이블 공간 필요

2. **메모리 접근 시간 증가**
   - 메모리 접근을 위해 페이지 테이블 참조 필요
   - 실제 데이터 접근 전에 페이지 테이블 접근 필요
## TLB (Translation Look-aside Buffer)
* 페이지 테이블의 캐시 역할
* 최근에 사용된 페이지 번호와 프레임 번호의 쌍을 저장

### 해결방법

#### 1. 계층적 페이지 테이블 (Hierarchical Page Table)
- 페이지 테이블을 여러 레벨로 구성
- 장점:
  - 실제 사용하는 페이지 테이블만 메모리에 유지
  - 메모리 절약
- 단점:
  - 주소 변환 시 여러 번의 메모리 접근 필요

#### 2. 해시 페이지 테이블 (Hashed Page Table)
- 페이지 번호를 해시하여 페이지 테이블 엔트리 찾기
- 장점:
  - 큰 주소 공간도 효율적으로 처리
- 단점:
  - 해시 충돌 처리 필요

#### 3. 역페이지 테이블 (Inverted Page Table)
- 시스템에 하나의 페이지 테이블만 존재
- 물리 메모리의 각 프레임별로 엔트리 유지
- 장점:
  - 페이지 테이블 크기 감소
- 단점:
  - 테이블 검색 시간 증가
  - 공유 페이지 구현이 복잡

