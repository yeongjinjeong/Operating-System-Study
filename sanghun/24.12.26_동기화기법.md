# 멀티스레드 동기화 기법
1. 락(lock) 방식 : 뮤텍스(mutex), 스핀락(spinlock)
2. wait-signal 방식 - 세마포(semaphore)

### 뮤텍스
* 락변수(locked/unlocked)를 이용하여 한 스레드만 임계구역 진입
* 나머지 스레드들을 큐에 대기
  - 변수 -락(lock) 변수
  - 연산 -lock/unlock 연산
  - 큐 -대기큐(wait queue)
* 락이 잠겨 있는 경우 풀릴때까지 블록 상태로 대기 큐에서 잠을 잔다.
* 임계구역의 실행 시간이 짧으면 비효육적
* 락이 잠겨있는 시간보다 컨텍스트 스위칭이 크면 비효율적

### 스핀락
* 락 기반으로 작동, **대기큐가 없다.**
* lock 연산은 락이 잠겨 있으면 **무한 루프**
1. 락이 잠겨 있으면 블록 되지 않고 열릴 때까지 검사 코드 실행
2. 단일 CPU를 가진 운영체제에서 매우 비효율적, 멀티 코어에서는 효과적이다.
3. 임계구역 코드가 짧아 락이 빨리 열리는 경우 효과적
4. 스레드들이 경쟁하기 때문에 운없게 기아가 발생하는 스레드 있을 수 있다.


### 하이브리드 뮤텍스 (hybrid mutex)
* 뮤텍스와 스필낙을 혼합한 방식
* 스핀락처럼 동작하다가 일정 시간까지 락을 얻지 못하면 블록 상태로 대기큐에 넣는다.

### 뮤텍스와 스핀락 비교
1. 락이 잠기는 시간이 길면 뮤텍스가 효율적이다.
2. 단일 CPU면 뮤텍스가 적합
3. 멀티코어에서는 스핀락이 효육적
4. 뮤텍스는 사용자모드에서 주로 이용, 스핀락은 커널과 인터럽트 서비스 루틴에 주로 사용
   - 인터럽트는 빨리 실행되어야하고 커널코드는 보통 짧도록  설정된다.
------------
### 세마포
* n개의 자원을 다수의 스레드가 공유하며 사용하도록 돕는 자원 관리 기법
  - 자원 n개, 대기큐, counter(사용 가능한 자원의 수, 원자명령으로 구성), 자원 요청/반환 연산으로 구성
* 자원을 얻을 때까지 대기(wait)하고 자원이 끝낸 스레드는 대기하는 스레드에게 알린다.(signal)
#### 수면 대기 세마포(sleep-wait)
* 자원 사용이 허가받지 못한 스레드는 대기 큐에 wait하게 한다
* 자원이 생기면 스레드를 깨워 사용
#### 바쁜 대기 세마포(busy-waiting)
* 자원이 생길 때까지 무한 루프로 검사하는 방식

#### 이진 세마포(binary semaphore)
* 자원이 1개인 경우
* 뮤텍스와 매우 유사하다.

--------

### 우선순위 역전 문제
* RTOS와 우선순위 기반 운영체제에서 일어난다.
* 우선순위 낮은 스레드가 임계구역에서 우선순위 높은 스레드로 컨테스트 스위칭이 방생하면 생길 수 있다.
* 우선순위 높은 스레드가 늦게 실행되는 문제발생 할 수 있다.
  - 우선순위 올림 해결(priority ceiling) : 공유자원에 접근 하는 어떤 스레드보다 높은 우선순위 부여했다가 되돌린다.
  - 우선순위 상속 (priority inheritance) : 공유자원 요청한 스레드보다 우선순위 조금 높게 변경했다 되돌린다.

------------
### 생산자 소비자 문제
* 유한 크기의 공유 버퍼에 데이터를 공급하는 생산자와 데이터를 소비하는 소비자가 공유버퍼를 문제없이 사용하도록 하는 문제(실행 순서 제어).
1. 문제 1 : 상호배제(공유 버퍼 사용에 대한 상호배제)
2. 문제 2 : 공유버퍼 비어 있을 때(비어있는 공유버퍼 소비자가 읽을때)
3. 문제 3 : 공유버퍼 꽉 찼을 때(꽈 찬 공유버퍼 생산자가 쓸 때)

#### 상호 배제 해결
* 임계구역에 뮤텍스나 세마포를 사용해서 해결한다

#### 공유버퍼 비었을 때
* 공유버퍼에 데이터가 기록될 때까지 소비자가 기다리도록 한다(wait).
* 생산자가 공유버퍼에 데이터를 쓰면 signal을 보내 소비자를 깨운다. 세마포가 적당
#### 공유버퍼가 꽉찼을 때
* 생산자는 버퍼가 기록전에 꽉 찼는지 확인
* 버퍼가 하나라도 비울 때까지 대기
* 소비자는 데이터를 읽은 후 대기하는 생산자를 깨운다. 세마포 적당.

