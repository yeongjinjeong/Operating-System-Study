# 가상메모리
* 물리메모리보다 큰 프로세스나 여러 개의 작은 프로세스를 동시에 실행시켜, 사용자나 응용프로그램에게 무한대의 메모리가 있다고 느끼도록 하는 메모리 관리 기법
1. 운영체제는 물리 메모리의 영역을 하드 디스크까지 연장
2. 프로세스가 실행될 때 프로세스의 전체가 물리 메모리에 적재되어 있을 필요는 없다.
3. 물리 메모리에 빈 영역이 부족하게 되면, 운영체제는 프로세스를 구분하지 않고 물리 메모리의 일부분을 하드 디스크에 옮겨 물리 메모리의 빈 영역 확보
4. 물리 메모리를 확장하여 사용하는 역역을 스왑영역이라고 한다.
5. 가상 메모리를 사용하면 사용자는 무한대에 가까운 물리메모리가 있어 여러 프로그램을 동시에 실행 가능하다.


# 가상 메모리 구현
* 요구 페이징 : 페이징 기법을 토대로 일부 페이지들만 메모리에 적재, 필요할때 메모리에 할당
* 요구 세그먼테이션: 세그먼테이션 기법 토대, 일부 세그먼트들만 메모리에 적제, 필요할때 할당
> 현대 운영체제는 대부분 요구 페이징 기법 사용

### 요구 페이징
* 페이지가 필요할때 물리 메모리를 할당받고 디스크에서 읽어 적재

#### 디스크 스왑영역
* 메모리에 적재되었다가 수정된 페이지들이 메모리에서 쫓겨날때 저장되는 영역

### 요구 페이징 테이블
* 페이징 테이블에 3개의 필드 추가
  - 메모리에 적재되어 있는지 나타내느 비트
  - 페이지가 메모리에 적재된 후 수정되었는지
  - 메모리에 적재되어 있으면 물리주소, 디스크에 있으면 디스크 주소가 저장되어 있는 필드

### 페이지 폴트
* CPU가 가상 주소를 발생시켜 엑세스하려는 페이지가 현재 물리 메모리에 없을 때
* 페이지폴트 발생하면 page fault handler코드 실행
* 물리메모리에 빈 프레임 할당받는다.
* 물리메모리가 꽉차면 프레임중 하나를 희생 시킨다.


### 스래싱(thrashing)
* 페이지 폴트가 계속 발생하여 메모리 프레임에 페이지가 반복적으로 교체되고 디스크 입출력이 심각하게 증가하여 CPU활용률이 대폭 감소하는 현상

#### 스래싱 원인
* 다중프로그래밍 정도가 과도한 경우 : 각 프로세스마다 할당된 프레임의 개수가 작아진다.
* 메모리 할당 정책이나 페이지 교체 알고리즘이 잘못되었을 경우
* 메모리가 절대적으로 작은 경우
* 특정 시간대에 너무 많은 프로세스 실행하는 경우
> 동시에 실행되는 프로세스의 개수가 많음에도 CPU 활용륭이 갑자기 떨어질 때 스레싱 발생한것으로 판단

#### 해결 방안 및 예방
* 몇개의 프로세스를 강제 종료
* 다중 프로그래밍의 허용치 낮춘다.
* 메모리를 늘리자

## 참조의 지역성
* CPU가 프로그램을 실행하는 동안 짧은 시간 범위 내에 일정 구간의 메모리 영역을 반복참조하는 경향

##### 시간 지역성
* 지금 참조되는 주소가 가까운 미래에 다시 참조될 가능성이 큰 특성
* 반복문이 대표적

##### 공간 지역성
* 지금 참조되는 주소가 주변 번지들이 가까운 미래에 참조되는 특성
* 배열이 대표적

#### 작업 집합
* 프로세스가 일정 시간 범위 내에 참조한 페이지들의 집합
* 작업 집합에 포함된 페이지들이 메모리에 있으면 그 프로세스는 한동한 페이지 폴트 없이 실행 가능할 수 있을것이다.
* 페이지 폴트가 계속된다면 프로세스의 작업 집합 페이지를 메모리에 적재하는 과정이라 생각해도 된다.
* 작업 집합에 포함된 페이지들이 충분히 메모리에 있지 못하면 스래싱이 발생하는 경우가 많다.

### 요구 페이징의 필수 알고리즘
* 프레임 할당 : 프로세스에게 할당할 메모리 프레임의 개수 문제
* 페이지 교체 : 페이지 폴트가 발생했을 때 빈 프레임 없으면 어떤 페이지를 스왑 시킬지 선택문제

#### 프레임 할당
* 균등 할당 : 프로세스 크기에 관계없이 모든 프로세스에게 동일하게 프레임 할당 큰 프로세스는 프레임 부족발생할수 있다.
* 비례 발당 : 큰 프로세스에겐 많이 작은 프로세스에게는 적게, 프로세스의 크기를 명확히 알기 어렵다는 문제가 있다.
* 이론적으로 프로세스에게 프레임의 적정 개수는 작업 집합을 약간 넘나드는 수준이 적합


#### 페이지 교체
* 요청된 페이지가 메모리 프레임에 없고 적재할 빈 프레임도 없는 경우 메모리 프레임 중하나를 선택하여 비우고 요청된 페이지를 적재하는 과정
* 쫓겨나는 프레임을 희생 프레임 쫓겨나는 페이지를 희생 페이지라고 한다.

#### 페이지 교체의 목표
* 현재 작업 집합에 포함되지 않거나 가까운 미래에 참조되지 않을 페이지를 희생 페이지로 선택하여 페이지 폴트의 횟수를 줄이는 것

#### 희생 프레임 선택 범위
* 지역 교체 : 프로세스에게 할당된 프레임들중에서 선택
* 전역 교체 : 프로세스에 상관없이 전체 메모리 프레임 중에서 선택
> 대부분 전역 교체 사용 windows는 둘다 혼합하여 사용한다

## 페이지 교체 알고리즘

#### 최적 교체 알고리즘 (Optimal Page Replacement)
* 미래에 사용될 가능성이 가장 낮은 페이지를 선택해서 교체. 최고의 이상적인 방법
* 미래에 언제 참조되는지 알아야 구현 가능하기 때문에 실현하기 어렵다.
* 다른 알고리즘 평가 기준으로 삼는다.

#### FIFO 알고리즘
* 가장 오래된 페이지를 선택해서 교체
* 구현이 쉽지만 작업 집합을 고려하지 않아 성능이 낮을 수 있다.
* 예를 들어 적재된 지 오래된 페이지도 자주 사용될수 있다.
> Belady anomaly : FIFO알고리즘의 경우 프로세스에게 더 많은 프레임을 할당해도 페이지 폴트가 더 많이 생기는 현상이 있다


#### LRU 알고리즘
* 가장 오래전에 참조된 페이지를 선택해 교체
* 참조의 지역성 원리에 근거
* 성능이 좋게 평가되지만 구현의 복잡도가 높다.

#### Clock 알고리즘
* LRU와 FIFO를 섞은 알고리즘, 근사 LRU라고도 한다.
* 참조비트를 사용한다. 검색 시작위치를 포인터로 가리킨다. 원형큐로 프레임를 관리한다.
* 참조 비트가 0을 만날때까지 1을 0으로 바꾸며 찾아서 0인 비트인 프레임을 교체하고 포인터를 다음 위치에 놓는다.
