# HDD Scheduling
- 하드 디스크에 저장된 데이터를 효율적으로 탐색하고자 하는 방법
- 접근 시간 최소화, 데이터 전송 대역폭 최대화

## FIFO Scheduling
- 처음 들어온 요청부터 순서대로 처리
- 간단하면서 공평한 방식이나, 최적의 서비스 제공은 어려움

## SCAN Scheduling
- 디스크 헤드가 디스크의 한쪽 끝에서 반대쪽 끝으로 이동하면서 처리
- 트랙의 끝에 도달하면 반대 방향으로 이동

## C-SCAN Scheduling
- 디스크 헤드가 디스크의 끝에 도달하면 트랙의 시작점으로 이동

# RAID(Redundant Array of Independent Disk)
- 여러 개의 디스크를 하나로 묶어 하나의 디스크처럼 사용하는 기술
- RAID의 목적
  - 드라이브를 병렬로 운영함으로써 데이터의 읽기/쓰기 속도 향상
  - 데이터를 복제하여 저장함으로써 저장소의 신뢰성(안정성) 향상
### Striping
- 연속된 데이터를 여러 개의 디스크에 Round Robin 방식으로 기록하는 기술
- 여러 디스크에서 병렬적으로 데이터를 읽을 수 있으므로 속도는 향상되나, 안정성은 떨어짐

### Mirroring
- 다른 디스크에 데이터를 중복 저장하는 기술
- 데이터의 안정성이 향상되나, 중복 저장할 디스크를 마련해야 하므로 비쌈

### Error detection: parity bit
- 데이터 바이트의 비트 1의 개수가 짝수냐, 홀수냐에 따라 패리티 비트 부여
- 데이터가 손상되었을 시, 패리티 비트를 통해 오류 검출 가능

## RAID Levels
### RAID 0
- 여러 디스크를 striping하여 데이터의 입출력 속도 및 저장 공간 향상
- 디스크가 하나만 손상되어도 전체 데이터가 손상되며, 오류 검출 코드 X

### RAID 1
- 디스크를 mirroring하여 다른 디스크에 데이터를 중복 저장
- 데이터 저장 안정성이 뛰어나나, 데이터가 많아질수록 mirroring할 디스크 많아짐, 비용 증가

### RAID 4
- 디스크를 블록 단위로 striping하고, 패리티 비트 저장을 위한 디스크 1개 사용
- striping과 함께 패리티 비트를 사용하여 안정성을 확보할 수 있으나, 패리티 디스크의 오버헤드 증가

### RAID 5
- 디스크를 블록 단위로 striping하고, 패리티 비트를 위한 디스크 1개 분량을 여러 디스크에서 돌아가면서 저장

### RAID 6
- 디스크를 블록 단위로 striping하고, 패리티 비트를 위한 디스크 2개 분량을 여러 디스크에서 돌아가면서 저장
- RAID 5보다 용량, 성능은 줄어들지만 안정성 향상

# Memory-mapped I/O
- 메모리와 I/O를 하나의 연속된 주소 영역에 할당하는 방식
- CPU에서는 메모리 접근과 I/O를 위해 같은 신호(read, write)를 사용
- 포트 입출력 구현 시 로직이 덜 필요하여 CPU 제작 비용이 저렴하고 빠름
- 주소와 데이터 버스를 많이 사용하게 되어 장치 접근 속도가 느림
- I/O 영역 변수는 volatile 타입으로 선언해서 컴파일러 최적화를 방지해야 함

## I/O 방식
### Polling
- busy bit가 clear될 때까지 상태 레지스터를 계속해서 읽는 방식
### Interrupt
- CPU가 인터럽트를 감지하면 이를 다루기 위해 ISR로 이동
- ISR의 주소는 interrupt vector table에 의해 정해짐
### DMA(Direct Memory Access)
- 레지스터를 통한 입출력을 피하기 위해, 직접 메모리 접근
- 대용량 데이터 전송에 유용

## Blocking I/O
- 입출력 시 스레드가 멈춤
- 스레드가 running queue에서 waiting queue로 이동

## Non-blocking I/O
- 입출력 시 스레드가 멈추지 않음
- 입력을 받을 경우, 가능한 한 즉시 리턴함

## Asynchronous system call
-  스레드가 코드 실행을 계속 해 나감
-  None-blocking I/O와 달리 입력 데이터 전송을 요청만 하고, 이후 코드를 계속 실행함

# Security Violations
- 위협(threat): 보안 위반에 대한 잠재적인 가능성, 우발적
- 공격(attack): 보안을 깨뜨리기 위한 시도, 의도적

## Security Violation의 유형
- 기밀성 침해(breach of confidentiality)
- 무결성 침해(breach of integrity)
- 가용성 침해(breach of availability)
- 서비스 가로채기(theft of service)
- 서비스 거부(denial of service, DoS)

## 4계층 보안 모델
- 응용 프로그램
  - 공격 유형: 로직의 버그, 설계 결함, 코드 인젝션
  - 공격 보호 방법: 샌드박싱, 소프트웨어 제한
- 운영 체제
  - 공격 유형: 안전하지 않은 초기값(insecure defaults), 플랫폼 취약점
  - 공격 보호 방법: 패치, 재구성, 하드닝(hardening)
- 네트워크
  - 공격 유형: 스니핑, 스푸핑, 마스커레이딩
  - 공격 보호 방법: 암호화, 인증, 필터링
- 물리적
  - 공격 유형: 콘솔 접근, 하드웨어 기반 공격
  - 공격 보호 방법: guards, vaults, 장치 데이터 암호화
 
## 프로그램의 보안 허점
- 맬웨어(malware)
  - 컴퓨터 시스템을 악용, 비활성화하거나 손상시키고자 설계된 소프트웨어
  - 트로이 목마, 스파이웨어, 랜섬웨어, 백도어, 논리 폭탄
- 코드 인젝션(code injection)
  - 대부분의 소프트웨어는 악의적이지 않지만, 코드 인젝션 공격으로 인해 심각한 위협을 일으킬 수 있음
- 바이러스와 웜
  - 바이러스는 합법적인 프로그램에 내장된 코드 조각이다.
  - 바이러스는 자가 복제하여 다른 프로그램을 감염시키도록 설계되었다.
  - 웜은 네트워크를 사용하여 사람의 도움 없이 자가 복제한다.
 
## 네트워크 트래픽을 통한 공격
- 스니핑(sniffing): 공격자가 수동적인 상태를 유지하면서 네트워크 트래픽을 가로챔
- 스푸핑(spoofing): 공격자가 집단 중 하나로 위장하거나, 중간자가 되어 두 피어 간의 트랜잭션을 가로채거나 수정
- 서비스 거부(denial of service)
  - 정보 획득이나 자원 탈취를 목표로 하지 않음
  - 시스템이나 시설의 합법적인 사용을 불가능하게 함
- 포트 스캐닝(Port Scanning)
  - 공격은 아니지만, 취약점을 탐지하기 위한 수단
 
# 암호화 알고리즘
- 대칭
  - 암호화와 복호화에 같은 키 사용
  - 해당 키는 비밀이 유지되어야 함
- 비대칭
  - 암호화와 복호화 각각에 다른 키 사용
  - 공개키와 개인키
 
## 대칭 암호화
- 키의 교환이 두 집단 사이에서 직접적으로 일어나거나, 신뢰할 수 있는 제 3집단(인증된 시설)을 통해 일어남
- 대칭 암호화 알고리즘: DES, AES

## 비대칭 암호화
- 누구나 수신자에게 메시지를 암호화해서 보낼 수 있음
- 수신자만이 메시지를 복호화 가능
- 비대칭 암호화 알고리즘: RSA

# 기타 보호 방법
## 샌드박싱(Sandboxing)
- 컴퓨터에서 어떤 프로그램이나 코드를 실행할 때 격리된 공간을 제공하고, 그곳이 아닌 다른 곳으로 벗어나 허용되지 않은 작업을 하지 못하도록 방지하는 기술
- Java와 .NET은 가상 머신 레벨에서 샌드박싱 부여

## 코드 서명(Code Signing)
- 프로그램이나 실행 가능한 코드의 디지털 서명으로, 생성 이래로 변경 사항이 없음을 나타냄
- 운영체제 배포, 패치, 서드파티 툴, 모바일 앱에 사용됨
