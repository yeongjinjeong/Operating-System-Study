# HDD Scheduling
- 하드 디스크에 저장된 데이터를 효율적으로 탐색하고자 하는 방법
- 접근 시간 최소화, 데이터 전송 대역폭 최대화

## FIFO Scheduling
- 처음 들어온 요청부터 순서대로 처리
- 간단하면서 공평한 방식이나, 최적의 서비스 제공은 어려움

## SCAN Scheduling
- 디스크 헤드가 디스크의 한쪽 끝에서 반대쪽 끝으로 이동하면서 처리
- 트랙의 끝에 도달하면 반대 방향으로 이동

## C-SCAN Scheduling
- 디스크 헤드가 디스크의 끝에 도달하면 트랙의 시작점으로 이동

# RAID(Redundant Array of Independent Disk)
- 여러 개의 디스크를 하나로 묶어 하나의 디스크처럼 사용하는 기술
- RAID의 목적
  - 드라이브를 병렬로 운영함으로써 데이터의 읽기/쓰기 속도 향상
  - 데이터를 복제하여 저장함으로써 저장소의 신뢰성(안정성) 향상
### Striping
- 연속된 데이터를 여러 개의 디스크에 Round Robin 방식으로 기록하는 기술
- 여러 디스크에서 병렬적으로 데이터를 읽을 수 있으므로 속도는 향상되나, 안정성은 떨어짐

### Mirroring
- 다른 디스크에 데이터를 중복 저장하는 기술
- 데이터의 안정성이 향상되나, 중복 저장할 디스크를 마련해야 하므로 비쌈

### Error detection: parity bit
- 데이터 바이트의 비트 1의 개수가 짝수냐, 홀수냐에 따라 패리티 비트 부여
- 데이터가 손상되었을 시, 패리티 비트를 통해 오류 검출 가능

## RAID Levels
### RAID 0
- 여러 디스크를 striping하여 데이터의 입출력 속도 및 저장 공간 향상
- 디스크가 하나만 손상되어도 전체 데이터가 손상되며, 오류 검출 코드 X

### RAID 1
- 디스크를 mirroring하여 다른 디스크에 데이터를 중복 저장
- 데이터 저장 안정성이 뛰어나나, 데이터가 많아질수록 mirroring할 디스크 많아짐, 비용 증가

### RAID 4
- 디스크를 블록 단위로 striping하고, 패리티 비트 저장을 위한 디스크 1개 사용
- striping과 함께 패리티 비트를 사용하여 안정성을 확보할 수 있으나, 패리티 디스크의 오버헤드 증가

### RAID 5
- 디스크를 블록 단위로 striping하고, 패리티 비트를 위한 디스크 1개 분량을 여러 디스크에서 돌아가면서 저장

### RAID 6
- 디스크를 블록 단위로 striping하고, 패리티 비트를 위한 디스크 2개 분량을 여러 디스크에서 돌아가면서 저장
- RAID 5보다 용량, 성능은 줄어들지만 안정성 향상

# Memory-mapped I/O
- 메모리와 I/O를 하나의 연속된 주소 영역에 할당하는 방식
- CPU에서는 메모리 접근과 I/O를 위해 같은 신호(read, write)를 사용
- 포트 입출력 구현 시 로직이 덜 필요하여 CPU 제작 비용이 저렴하고 빠름
- 주소와 데이터 버스를 많이 사용하게 되어 장치 접근 속도가 느림
- I/O 영역 변수는 volatile 타입으로 선언해서 컴파일러 최적화를 방지해야 함

## I/O 방식
### Polling
- busy bit가 clear될 때까지 상태 레지스터를 계속해서 읽는 방식
### Interrupt
- CPU가 인터럽트를 감지하면 이를 다루기 위해 ISR로 이동
- ISR의 주소는 interrupt vector table에 의해 정해짐
### DMA(Direct Memory Access)
- 레지스터를 통한 입출력을 피하기 위해, 직접 메모리 접근
- 대용량 데이터 전송에 유용

## Blocking I/O
- 입출력 시 스레드가 멈춤
- 스레드가 running queue에서 waiting queue로 이동

## Non-blocking I/O
- 입출력 시 스레드가 멈추지 않음
- 입력을 받을 경우, 가능한 한 즉시 리턴함

## Asynchronous system call
-  스레드가 코드 실행을 계속 해 나감
-  None-blocking I/O와 달리 입력 데이터 전송을 요청만 하고, 이후 코드를 계속 실행함
