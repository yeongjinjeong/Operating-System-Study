# Deadlocked
자원을 가지고 있는 둘 이상의 프로세스가 서로의 자원을 요구함으로써 계속 대기하는 상태

## 필요조건
- Mutual Exclusion(상호배제)
  - 공유 자원에 접근하는 프로세스의 수를 제한
- Hold and Wait(점유와 대기)
  - 프로세스가 하나 이상의 자원을 점유한 상태에서, 다른 프로세스가 점유 중인 자원을 얻으려고 대기
- No Preemption(비선점)
  - 다른 프로세스가 사용 중인 자원을 점유 불가능
- Circular Wait(원형 대기)
  - 여러 프로세스 각각이 자신의 다음 또는 이전 번째 프로세스가 점유 중인 자원을 요구

# Deadlock 문제 해결
## Deadlock 예방
- Deadlock의 발생 조건 4가지 중 하나를 제거하면 막을 수 있다.
- 장치 이용률 저하와 시스템 처리량 감소 부작용 발생

### Mutual Exclusion 예방
- 공유 자원을 프로세스 여럿이서 접근할 수 있도록 허용
- Mutex lock 등의 프로세스 동기화 기법과 대치되므로 비현실적

### Hold and Wait 예방
- 프로세스가 필요 자원을 동시에 점유하도록 함
- 프로세스가 자원을 점유한 상태에서 다른 자원을 요구할 경우, 점유한 자원을 반납한 상태에서 다시 요구하도록 함
- 비효율적인 자원 활용으로 인해 실용성이 떨어짐

### No Preemption 예방
- 프로세스가 사용 중인 자원을 점유 가능하도록 변경
- 커널 시스템 자원의 선점이 가능해질 경우 문제 발생, 비현실적

### Circular Wait 예방
- 자원 유형(resource type)에 순서를 매겨서, 특정한 순서로만 자원을 요청하도록 함
- 그나마 현실적인 방안이나, 여러 스레드에서 여러 mutex lock을 동시에 얻으려 할 때 deadlock이 발생할 수 있어서 완벽하지 않음

## Deadlock 회피
- 시스템이 스레드의 자원 할당 요청을 받으면 잠시 대기시키고, 자원 할당에 따른 deadlock 발생 여부를 판단
- 스레드의 최대 요구 자원, 현재 자원의 할당 상태 등의 정보가 추가로 필요함
- Safe state: 시스템에 스레드의 safe sequence가 존재하여 자원을 deadlock 없이 할당할 수 있는 상태
- Unsafe state: 시스템에 deadlock이 발생할 수 있는 상태 (반드시 발생하는 것은 아님)

### Resource-Allocation Graph

### Banker's Algorithm

## Deadlock 탐지/복구
