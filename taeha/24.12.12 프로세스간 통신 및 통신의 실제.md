# 프로세스간 통신 및 통신의 실제
## IPC(Inter-Process Communication)
- 프로세스는 고유한 메모리 영역을 갖기 때문에, 일반적으로 프로세스 간 직접적인 데이터 접근이 불가능하다.
- 독립 프로세스(independent process)는 다른 프로세스와 데이터를 공유하지 않는다.
- 하지만 협력 프로세스(cooperating process)는 다른 프로세스와 데이터를 공유하며, 프로세스 서로 간 영향을 끼칠 수 있다.
- IPC는 cooperating process 간 데이터를 송수신하기 위한 메커니즘이다.

## IPC의 기본 모델
- Shared memory는 두 프로세스가 공통으로 공유하는 메모리 영역을 통해 데이터를 주고받는 방식이다. Shared memory의 할당은 OS에서 관리한다. 여러 프로세스가 공유 메모리 영역을 필요로 하므로, 여기에 접근하거나 조작하는 코드는 애플리케이션 프로그래머가 명시적으로 작성하여야 한다.
- Message passing은 두 프로세스의 데이터 송수신을 OS가 중개하는 방식이다.

## Message Passing
### Direct Communication
- 메시지가 송신 프로세스와 수신 프로세스 간에 직접 전달되는 방식이다.
- 송신자는 수신자의 ID를 명시적으로 지정해야 한다.

### Indirect Communication
- 메시지가 중간 매개체(mailbox 또는 ports)를 통해 전달되는 방식이다.
- 송신자는 메시지를 특정한 mailbox에 보낸다.
- 수신자는 해당 mailbox에서 메시지를 가져온다.

### Synchronous Communication
- 메시지 송신과 수신이 동시에 발생한다.
- 송신자는 메시지를 보낸 뒤 수신자가 받기 전까지 block 상태가 된다. (Blocking send)
- 수신자는 송신자의 메시지를 받을 때까지 block 상태이다. (Blocking receive)

### Asynchronous Communication
- 메시지 송신과 수신이 비동기적으로 처리된다.
- 송신자는 메시지를 보내고 계속 작업을 수행한다. (Non-blocking send)
- 수신자는 유효한 메시지나 null 메시지를 받아올 수 있다. (Non-blocking receive)

### Automatic Buffering
- 메시지가 OS에서 관리하는 버퍼에 자동으로 저장된다.
- 송신자는 메시지를 전송하면 운영체제가 이를 저장하고 수신자가 읽어갈 때까지 유지한다.

## POSIX Shared Memory
POSIX API를 활용하여 공유 메모리를 구현한다.

memory-mapped file을 사용하여 하드 디스크에서 파일을 읽는 것보다 빠른 읽기/쓰기가 가능하다.

```
#include <sys/mman.h>

int shm_open(const char *name, int oflag, mode_t mode);
```
- ```name```: object의 이름, 해당 shared memory에 접근하기 위해 필요
- ```oflag```: 입출력 방식 플래그, ```<fcntl.h>```에 선언되어 있음
- ```mode```: shared-memory object에 대한 파일 접근 허가권
- 리턴값: 성공 시 shared-memory object에 대한 file descriptor를 나타내는 정수, 실패 시 -1

```shm_open()``` system call을 통해 shared-memory object를 생성한다.
```
int fd;
fd = shm_open("OS", O_CREAT | O_RDWR, 0666);    // "OS"라는 이름의 shared-memory object를 읽기/쓰기 모드로 생성
```
Object의 크기를 설정한다.
```
ftruncate(fd, 4096);    // object fd의 크기를 4096 byte로 설정
```
memory-mapped file을 설정한다.
```
char* ptr;
ptr = (char*)mmap(0, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);    // shared-memory object에 대한 mapping을 생성
```
producer가 shared memory에 메시지를 쓴다.
```
const char* message_0 = "Hello";
const char* message_1 = "World!";

sprintf(ptr, "%s", message_0);
ptr += strlen(message_0);
sprintf(ptr, "%s", message_1);
ptr += strlen(message_1);
```
consumer가 shared memory의 메시지를 읽는다.
```
fd = shm_open(name, O_RDONLY, 0666);
ptr = (char*)mmap(0, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

printf("%s", (char*)ptr);
```
shared-memory object를 제거한다.
```
shm_unlink(name);
```

## Pipes
- 일찍이 UNIX 시스템에 있던 최초의 IPC 메커니즘 중 하나
- Pipe는 두 프로세스 간 상호작용을 해 주는 관과 같은 역할을 한다.

### Ordinary pipes
- 부모 프로세스가 자식 프로세스와 상호작용을 위해 생성한 pipe이다.
- 단방향 상호작용만 가능하며, 양방향 커뮤니케이션을 위해서는 두 개의 pipe를 사용해야 한다.

### Named pipes
- 부모-자식 프로세스 관계 없이도 접근할 수 있다.

## Sockets
- 네트워크 소켓을 이용하는 프로세스 간 통신이다.
- Java에서는 Socket, DatagramSocket, MulticastSocket 세 종류의 소켓을 제공한다.

## RPCs(Remote Procedure Call)
- 원격 서비스에서 가장 일반적인 형태
- 분산 시스템에서 원격 프로시저 호출을 수행하는 통신 방식
