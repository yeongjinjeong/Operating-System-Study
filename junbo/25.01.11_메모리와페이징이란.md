# 1. 메모리 주소는 어떻게 정해지는지 과정을 말씀해주세요  
  
실행 파일 내부의 명령어들은 주소 바인딩(Address Binding) 과정을 거쳐서 주소를 할당 받습니다.  
먼저 소스 코드 단계에서 사용하는 Symbolic Address(기호 주소) 는 컴파일을 거치면서 Relocatable Address(재배치 가능한 주소) 가 되고,  
실행 시점이나 링크 시점에 최종적으로 Absolute Address(절대 주소) 로 결정됩니다.  
  
이때 프로세스가 실행 중에 사용하는 주소는 논리 주소(Logical Address) 라고 부르는데,  
이는 실제 하드웨어 주소가 아니라 CPU 관점에서 생성된 주소입니다.  
따라서, MMU(Memory Management Unit) 를 사용하여 논리 주소를 물리 주소를 매핑하여 메모리에 접근해야 합니다.  
  
  
# 2. DLL 파일을 만들어 본적이나 써본적이 있나요?  
  
직접 DLL을 만들어 사용해본 적은 없습니다만 개념은 알고 있습니다.  
DLL(Dynamically Linked Library)은 동적 링킹(dynamic linking) 을 통해 여러 프로그램이 동시에 공유할 수 있는 라이브러리 파일(shared library)입니다.  
이 방식은 프로그램 실행 시점에 필요한 코드나 함수를 동적으로 로드하여 사용할 수 있으며,  
디스크 및 메모리 사용량을 절약하고, 라이브러리를 수정했을 때 재배포가 용이하다는 장점이 있습니다.  
  
  
# 3. 멀티 프로세싱에서 메모리 보호는 어떻게 할 수 있나요?  

멀티 프로세싱 환경에서 프로세스 간 메모리 독립성을 보장하기 위해, 하드웨어적으로 Base Register 와 Limit Register 를 사용합니다.  
각 프로세스가 사용할 수 있는 시작 주소(Base)와 그 범위(Limit)를 지정해 두고, CPU가 메모리에 접근할 때 이 범위를 벗어나면 접근을 차단(세그멘테이션 폴트)합니다.  
  
또한 비교적 단순한 시스템에서는 프로세스마다 연속적인(Contiguous) 메모리 공간을 할당하는데,  
이때는 하나의 프로세스가 차지하는 물리 주소 범위가 한 덩어리로 이어지므로,  
Base Register 와 Limit Register 를 사용하여 범위를 넘어가는 것을 제한하는 방식으로 간단하게 메모리 보호를 구현할 수 있습니다.  
  
  
# 4. 연속 메모리 할당 방법에는 무엇이 있고, 어떤 문제가 있을 수 있나요?  

연속 메모리 할당 방식을 사용할 때, 빈 메모리 블록을 어떻게 찾느냐에 따라 First Fit, Best Fit, Worst Fit 등의 전략이 있습니다.  
  
First Fit: 메모리를 탐색하면서 가장 처음으로 발견된 충분한 크기의 블록에 프로세스를 할당합니다.  
Best Fit: 가장 작게 남는 블록(딱 맞거나 그에 가장 가까운)을 찾아서 할당합니다.  
Worst Fit: 가장 큰 빈 블록에 할당하여, 남은 블록을 크게 유지하려는 방법입니다.  
  
하지만 이러한 연속 할당 방식은 해제된 프로세스 자리가 여러 조각으로 나뉘면서 외부 단편화(External Fragmentation) 가 생길 수 있습니다.   
메모리에 프로세스를 놓을 수 있는 총량은 충분해도 연속된 큰 공간이 없으면 새 프로세스를 로드하기 어려워지는 문제가 발생합니다.  
  

# 5. 페이징에 대해서 설명해보세요.  

페이징(Paging)은 연속적인 큰 메모리 덩어리를 요구하지 않고, 메모리를 동일한 크기(frame) 로 나누어 비연속적으로 할당하는 방식입니다.   
프로세스의 논리 주소 공간도 페이지(Page) 라는 같은 크기로 잘라서, 어떤 페이지가 어느 프레임에 들어있는지를 페이지 테이블(Page Table) 로 관리합니다.  
  
TLB(Translation Lookaside Buffer) 는 페이지 테이블 조회를 빠르게 하기 위한 캐시 역할을 합니다.  
페이지 번호를 TLB에서 먼저 찾아보아, 있으면 즉시 물리 주소를 얻을 수 있고, 없으면 실제 페이지 테이블을 참조하는 식으로 속도를 높입니다.  
  
페이징을 사용하면 외부 단편화 문제가 크게 완화되고, Swapping 역시 페이지 단위로 수행할 수 있어 효율적입니다.  
또한 Dynamic Loading(동적 로딩) 을 페이징과 결합하면, 필요한 페이지만 메모리에 로드하여 사용 가능하므로 메모리 사용량을 최소화할 수 있습니다.  
